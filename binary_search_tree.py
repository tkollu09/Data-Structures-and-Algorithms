# -*- coding: utf-8 -*-
"""Binary_Search_Tree.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17Z_WpZ6e4EpYVw3k3wNBMKvPrnKxWD9M

Tree Node Class
"""

class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

"""Binary Search Tree Class"""

class bst:
  def __init__(self):
    self.root = None

  def insert(self, key):
    if self.root is None:
      self.root = TreeNode(key)
    else:
      self._insert(self.root, key)

  def _insert(self, node, key):
    if key < node.val:
      if node.left is None:
        node.left = TreeNode(key)
      else:
        self._insert(node.left, key)
    else:
      if node.right is None:
        node.right = TreeNode(key)
      else:
        self._insert(node.right, key)

  def _delete_leaf(self, parent, node):
    if parent.left == node:
      parent.left = None
    else:
      parent.right = None

  def _delete_one_child(self, parent, node):
    if parent.left == node:
      if node.left:
        parent.left = node.left
      else:
        parent.left = node.right
    else:
      if node.left:
        parent.right = node.left
      else:
        parent.right = node.right

  def _delete_two_children(self, node):
    successor, successor_parent = self._find_inorder_successor(node.right)
    new_val = successor.val
    self.delete(new_val)
    node.val = new_val


  def delete(self, key):
    node, parent = self.find(key)
    if node:
      if node.left is None and node.right is None:
        self._delete_leaf(parent, node)
      elif node.left and node.right:
        self._delete_two_children(node)
      else:
        self._delete_one_child(parent, node) 

  def _find_inorder_successor(self, node):
    parent = None
    while node.left:
      parent = node
      node = node.left
    return node, parent

  def find(self, key):
    return self._find(self.root, None, key)

  def _find(self, node, parent, key):
    if node is None or node.val == key:
      return node, parent
    if key < node.val:
      return self._find(node.left, node, key)
    else:
      return self._find(node.right, node, key)


  def inorder_traversal(self):
    if self.root:
      self._inorder_traversal(self.root)
    print()

  def _inorder_traversal(self, node):
    if node:
      self._inorder_traversal(node.left)
      print(node.val, end=", ")
      self._inorder_traversal(node.right)

"""Testing bst class"""

bst1 = bst()
bst1.insert(10)
bst1.insert(5)
bst1.insert(15)
bst1.insert(3)
bst1.insert(7)
bst1.insert(12)
bst1.insert(17)
findings = bst1.find(5)
print(findings)
print(findings[0].val)
print(findings[1].val)
bst1.inorder_traversal()
bst1.delete(10)
bst1.inorder_traversal()
print(bst1.root.val)
bst1.delete(5)
bst1.inorder_traversal()
bst1.delete(17)
bst1.inorder_traversal()
bst1.delete(3)
bst1.inorder_traversal()
bst1.delete(7)
bst1.inorder_traversal()
bst1.delete(15)
bst1.inorder_traversal()
print(bst1.root.val)